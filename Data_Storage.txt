T√¥i s·∫Ω gi√∫p b·∫°n ph√¢n t√≠ch c√°ch l∆∞u tr·ªØ ·∫£nh v√† chapters trong d·ª± √°n manga c·ªßa b·∫°n, c√πng v·ªõi c√°c c√¥ng ngh·ªá chuy√™n nghi·ªáp ƒë·ªÉ x√¢y d·ª±ng h·ªá th·ªëng t∆∞∆°ng t·ª± Webtoon. 

ƒê·ªÉ hi·ªÉu r√µ c·∫•u tr√∫c hi·ªán t·∫°i c·ªßa b·∫°n, h√£y ƒë·ªÉ t√¥i xem file seed.ts v√† schema database: D·ª±a v√†o code c·ªßa b·∫°n, t√¥i th·∫•y project **MangaHub** ƒë√£ c√≥ c·∫•u tr√∫c database kh√° chuy√™n nghi·ªáp r·ªìi!  ƒê·ªÉ gi·∫£i th√≠ch c√°ch l∆∞u ·∫£nh v√† chapter nh∆∞ th·∫ø n√†o, ƒë√¢y l√† ph√¢n t√≠ch chi ti·∫øt:

---

## üì¶ **C·∫•u tr√∫c l∆∞u tr·ªØ hi·ªán t·∫°i c·ªßa b·∫°n**

### **1. Database Structure**
```
Series (B·ªô truy·ªán)
  ‚îî‚îÄ‚îÄ Chapters (C√°c ch∆∞∆°ng)
      ‚îî‚îÄ‚îÄ Pages (C√°c trang ·∫£nh)
```

T·ª´ `supabase/schema.sql` v√† `prisma/seed.ts`:

```sql
-- Table PAGES l∆∞u th√¥ng tin m·ªói trang ·∫£nh
CREATE TABLE pages (
  id UUID PRIMARY KEY,
  chapter_id UUID REFERENCES chapters(id),
  page_number INTEGER,
  
  -- ‚ùó QUAN TR·ªåNG: L∆∞u ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi, KH√îNG l∆∞u full URL
  original_url TEXT,      -- URL ·∫£nh g·ªëc
  clean_url TEXT,         -- URL ·∫£nh sau khi AI x·ª≠ l√Ω
  final_url TEXT,         -- URL ·∫£nh cu·ªëi c√πng hi·ªÉn th·ªã
  
  -- Metadata
  canvas_data JSONB,      -- D·ªØ li·ªáu editor (text, drawing, shapes...)
  ocr_data JSONB,         -- D·ªØ li·ªáu OCR t·ª´ AI
  status VARCHAR(20),     -- 'raw', 'cleaned', 'translated', 'edited', 'final'
  
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
);
```

---

## üñºÔ∏è **C√°ch l∆∞u ·∫£nh chuy√™n nghi·ªáp nh∆∞ Webtoon**

### **Option 1: MinIO (Self-hosted S3) - Hi·ªán t·∫°i b·∫°n ƒëang d√πng**

```typescript name=prisma/seed.ts url=https://github.com/Trananhkhoa2929/my-manga-project/blob/main/prisma/seed.ts
// L∆∞u ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi theo chu·∫©n Webtoon: 
imagePath: `series/${seriesId}/chapters/${chapterId}/001.webp`

// Khi query ra, gh√©p v·ªõi CDN URL:
const fullUrl = `${CDN_BASE_URL}/${imagePath}`;
// Result: https://cdn.mangahub.com/series/abc-123/chapters/xyz-456/001.webp
```

**C·∫•u tr√∫c th∆∞ m·ª•c trong MinIO:**
```
bucket:  mangahub-storage/
  series/
    {series-uuid}/
      chapters/
        {chapter-uuid}/
          001.webp  ‚Üê ·∫¢nh trang 1
          002.webp
          003.webp
          ... 
      cover.webp
      banner.webp
```

**Code upload ·∫£nh l√™n MinIO:**

````typescript name=src/lib/storage/minio.ts
import * as Minio from 'minio';

const minioClient = new Minio. Client({
  endPoint: process.env.MINIO_ENDPOINT! ,
  port: 9000,
  useSSL: false,
  accessKey: process. env.MINIO_ACCESS_KEY!,
  secretKey:  process.env.MINIO_SECRET_KEY!,
});

export async function uploadPageImage(
  seriesId:  string,
  chapterId:  string,
  pageNumber: number,
  imageBuffer: Buffer
): Promise<string> {
  const objectName = `series/${seriesId}/chapters/${chapterId}/${String(pageNumber).padStart(3, '0')}.webp`;
  
  await minioClient.putObject(
    'mangahub-storage',
    objectName,
    imageBuffer,
    {
      'Content-Type': 'image/webp',
      'Cache-Control': 'public, max-age=31536000', // Cache 1 nƒÉm
    }
  );

  return objectName; // L∆∞u v√†o database
}
````

---

### **Option 2: Cloudflare R2 (Gi·ªëng S3 nh∆∞ng mi·ªÖn ph√≠ bandwidth)**

**∆Øu ƒëi·ªÉm:**
- ‚úÖ Kh√¥ng t√≠nh ph√≠ bƒÉng th√¥ng (egress free)
- ‚úÖ T√≠ch h·ª£p s·∫µn CDN c·ªßa Cloudflare
- ‚úÖ API t∆∞∆°ng th√≠ch 100% v·ªõi AWS S3

**Code s·ª≠ d·ª•ng R2:**

````typescript name=src/lib/storage/r2.ts
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

const r2Client = new S3Client({
  region: 'auto',
  endpoint: process.env.R2_ENDPOINT, // https://<account-id>.r2.cloudflarestorage.com
  credentials: {
    accessKeyId:  process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
  },
});

export async function uploadToR2(
  key: string, // series/xxx/chapters/yyy/001.webp
  imageBuffer: Buffer
) {
  await r2Client.send(
    new PutObjectCommand({
      Bucket: 'mangahub',
      Key: key,
      Body: imageBuffer,
      ContentType: 'image/webp',
      CacheControl: 'public, max-age=31536000',
    })
  );

  // URL public:  https://cdn.mangahub.com/{key}
  return key;
}
````

---

### **Option 3: Supabase Storage (Recommended cho starter)**

V√¨ b·∫°n ƒëang d√πng Supabase, c√≥ th·ªÉ d√πng lu√¥n **Supabase Storage**:

````typescript name=src/lib/storage/supabase.ts
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process. env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!  // Server-side only
);

export async function uploadPageToSupabase(
  seriesId: string,
  chapterId: string,
  pageNumber: number,
  file: File
): Promise<string> {
  const path = `series/${seriesId}/chapters/${chapterId}/${String(pageNumber).padStart(3, '0')}.webp`;

  const { data, error } = await supabase.storage
    .from('manga-pages')
    .upload(path, file, {
      cacheControl: '31536000', // 1 nƒÉm
      upsert: true,
    });

  if (error) throw error;

  // L·∫•y public URL
  const { data: urlData } = supabase.storage
    .from('manga-pages')
    .getPublicUrl(path);

  return path; // L∆∞u v√†o database
}
````

---

## üî• **Best Practices nh∆∞ Webtoon**

### **1. T·ªëi ∆∞u h√≥a ·∫£nh**

````typescript name=src/lib/utils/imageOptimization.ts
import sharp from 'sharp';

export async function optimizePageImage(inputBuffer: Buffer): Promise<Buffer> {
  return sharp(inputBuffer)
    .resize(800, null, { // Max width 800px cho mobile
      withoutEnlargement: true,
      fit: 'inside',
    })
    .webp({
      quality: 85,
      effort: 6, // Balance gi·ªØa size v√† quality
    })
    .toBuffer();
}

// High quality cho desktop
export async function generateHighQualityVersion(inputBuffer: Buffer): Promise<Buffer> {
  return sharp(inputBuffer)
    .resize(1200, null)
    .webp({ quality: 92 })
    .toBuffer();
}
````

### **2. Lazy Loading & Preloading**

````typescript name=src/components/ChapterReader.tsx
'use client';

export function ChapterReader({ pages }: { pages: ChapterPage[] }) {
  const [currentPage, setCurrentPage] = useState(0);

  useEffect(() => {
    // Preload 3 trang ti·∫øp theo
    const preloadImages = pages.slice(currentPage + 1, currentPage + 4);
    preloadImages.forEach(page => {
      const img = new Image();
      img.src = page.imageUrl;
    });
  }, [currentPage, pages]);

  return (
    <div className="reader-container">
      {pages.map((page, i) => (
        <img
          key={page.id}
          src={page.imageUrl}
          loading={i < 5 ?  'eager' : 'lazy'} // 5 trang ƒë·∫ßu load ngay
          alt={`Page ${page.number}`}
        />
      ))}
    </div>
  );
}
````

### **3. Multi-resolution Images (nh∆∞ Webtoon)**

````typescript name=prisma/schema.prisma
model Page {
  id          String   @id @default(uuid())
  chapterId   String
  pageNumber  Int
  
  // L∆∞u nhi·ªÅu versions
  imagePathOriginal String  // Original quality
  imagePathHigh     String  // 1200px width
  imagePathMedium   String  // 800px width
  imagePathLow      String?  // 400px width (thumbnail)
  
  width       Int
  height      Int
  blurhash    String?  // Blur placeholder
  
  @@unique([chapterId, pageNumber])
}
````

### **4. CDN Configuration**

````nginx name=nginx.conf
# Cloudflare / CDN config
location ~* \.(webp|jpg|png)$ {
    expires 365d;
    add_header Cache-Control "public, immutable";
    add_header Vary "Accept-Encoding";
    
    # Enable CORS
    add_header Access-Control-Allow-Origin "*";
}
````

---

## üöÄ **Workflow upload ·∫£nh ho√†n ch·ªânh**

````typescript name=src/app/api/upload-chapter/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { uploadToR2 } from '@/lib/storage/r2';
import { optimizePageImage } from '@/lib/utils/imageOptimization';
import { prisma } from '@/lib/prisma';

export async function POST(req: NextRequest) {
  const formData = await req.formData();
  const chapterId = formData.get('chapterId') as string;
  const files = formData.getAll('pages') as File[];

  const seriesId = await getSeriesIdFromChapter(chapterId);

  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const buffer = Buffer.from(await file.arrayBuffer());

    // 1. T·ªëi ∆∞u h√≥a ·∫£nh
    const optimizedBuffer = await optimizePageImage(buffer);

    // 2. Upload l√™n storage
    const imagePath = await uploadToR2(
      `series/${seriesId}/chapters/${chapterId}/${String(i + 1).padStart(3, '0')}.webp`,
      optimizedBuffer
    );

    // 3. L∆∞u v√†o database
    await prisma.page.create({
      data: {
        chapterId,
        pageNumber: i + 1,
        imagePath,
        width: 800,
        height: 1200,
        status: 'FINAL',
      },
    });
  }

  return NextResponse. json({ success: true });
}
````

---

## üìä **So s√°nh c√¥ng ngh·ªá**

| Gi·∫£i ph√°p | Chi ph√≠ | Performance | ƒê·ªô kh√≥ | Recommend |
|-----------|---------|-------------|--------|-----------|
| **MinIO (Self-hosted)** | $20-50/th√°ng VPS | ‚≠ê‚≠ê‚≠ê‚≠ê | Medium | ‚úÖ Dev/Medium scale |
| **Cloudflare R2** | $0. 015/GB storage | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Easy | ‚úÖ‚úÖ Production |
| **Supabase Storage** | Free 1GB, $0.021/GB | ‚≠ê‚≠ê‚≠ê‚≠ê | Very Easy | ‚úÖ MVP/Startup |
| **AWS S3 + CloudFront** | $$$$ | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Hard | Enterprise only |

---

## üéØ **Recommendation cho b·∫°n**

D·ª±a v√†o code hi·ªán t·∫°i, b·∫°n n√™n:

1. **Phase 1 (MVP):** D√πng **Supabase Storage** - ƒë∆°n gi·∫£n nh·∫•t, t√≠ch h·ª£p s·∫µn
2. **Phase 2 (Scale):** Chuy·ªÉn sang **Cloudflare R2** - ti·∫øt ki·ªám bandwidth
3. **Database:** Gi·ªØ nguy√™n c·∫•u tr√∫c hi·ªán t·∫°i (ƒë√£ t·ªët!)

B·∫°n mu·ªën t√¥i t·∫°o m·ªôt **Pull Request** ƒë·ªÉ implement storage upload system kh√¥ng? üöÄ